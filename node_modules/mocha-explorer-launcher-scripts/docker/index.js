"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const util_1 = require("util");
const vscode_test_adapter_remoting_util_1 = require("vscode-test-adapter-remoting-util");
(function () {
    const log = (msg) => process.send(msg);
    const dockerImage = process.env['DOCKER_IMAGE'];
    if (!dockerImage) {
        log('No docker image configured - please set the DOCKER_IMAGE environment variable');
        return;
    }
    const localWorkspace = process.env['VSCODE_WORKSPACE_PATH'] || process.cwd();
    const dockerWorker = process.env['DOCKER_WORKER_PATH'] || '/worker.js';
    const dockerWorkspace = process.env['DOCKER_WORKSPACE_PATH'] || '/workspace';
    let dockerExtraArgs;
    try {
        dockerExtraArgs = JSON.parse(process.env['DOCKER_EXTRA_ARGS'] || '[]');
    }
    catch (_a) {
        log(`Couldn't parse DOCKER_EXTRA_ARGS: "${process.env['DOCKER_EXTRA_ARGS']}" is not a valid JSON string.`);
        return;
    }
    let port;
    try {
        port = +(process.env['DOCKER_WORKER_PORT'] || 8123);
    }
    catch (_b) {
        log(`Couldn't parse DOCKER_WORKER_PORT: "${process.env['DOCKER_WORKER_PORT']}" is not a number.`);
        return;
    }
    const localToDockerPath = (path) => (0, vscode_test_adapter_remoting_util_1.convertPath)(path, localWorkspace, dockerWorkspace);
    const dockerToLocalPath = (path) => (0, vscode_test_adapter_remoting_util_1.convertPath)(path, dockerWorkspace, localWorkspace);
    process.once('message', (origWorkerArgs) => __awaiter(this, void 0, void 0, function* () {
        log('Received workerArgs');
        const workerArgs = vscode_test_adapter_remoting_util_1.mochaWorker.convertWorkerArgs(origWorkerArgs, localToDockerPath);
        let nodeDebugArgs = [];
        let dockerDebugArgs = [];
        let delay = undefined;
        if (workerArgs.debuggerPort) {
            nodeDebugArgs = [`--inspect-brk=0.0.0.0:${workerArgs.debuggerPort}`];
            dockerDebugArgs = ['-p', `${workerArgs.debuggerPort}:${workerArgs.debuggerPort}`];
            delay = 2000;
        }
        log('Starting worker process');
        const childProcess = (0, child_process_1.spawn)('docker', [
            'run', '--rm',
            '-v', `${localWorkspace}:${dockerWorkspace}`,
            '-v', `${origWorkerArgs.workerScript}:${dockerWorker}`,
            '-p', `${port}:${port}`,
            ...dockerDebugArgs,
            ...dockerExtraArgs,
            dockerImage,
            'node',
            ...nodeDebugArgs,
            dockerWorker,
            `{"role":"server","port":${port}}`
        ], { stdio: 'inherit' });
        childProcess.on('error', err => log(`Error from docker: ${(0, util_1.inspect)(err)}`));
        childProcess.on('exit', (code, signal) => {
            log(`The docker process exited with code ${code} and signal ${signal}.`);
            if ((workerArgs.action === 'loadTests') && (code || signal)) {
                process.send({
                    type: 'finished',
                    errorMessage: `The docker process exited with code ${code} and signal ${signal}.\nThe diagnostic log may contain more information, enable it with the "mochaExplorer.logpanel" or "mochaExplorer.logfile" settings.`
                });
            }
        });
        if (delay) {
            yield new Promise(resolve => setTimeout(resolve, delay));
        }
        log('Connecting to worker process');
        const socket = yield (0, vscode_test_adapter_remoting_util_1.createConnection)(port);
        log('Sending workerArgs to worker process');
        yield (0, vscode_test_adapter_remoting_util_1.writeMessage)(socket, workerArgs);
        log('Finished initialising worker');
        (0, vscode_test_adapter_remoting_util_1.readMessages)(socket, (msg) => {
            if (workerArgs.action === 'loadTests') {
                process.send(vscode_test_adapter_remoting_util_1.mochaWorker.convertTestLoadMessage(msg, dockerToLocalPath));
            }
            else {
                process.send(vscode_test_adapter_remoting_util_1.mochaWorker.convertTestRunMessage(msg, dockerToLocalPath));
            }
        });
    }));
})();
