/// <reference types="node" />
import * as net from 'net';
/**
 * Loggers implementing this interface can be passed to `createConnection` and `receiveConnection`
 */
export interface ILog {
    debug(msg: string): void;
    info(msg: string): void;
    warn(msg: string): void;
    error(msg: string): void;
}
/**
 * Connect to the given port and return the socket if successful.
 * If the connection is rejected, this function will keep retrying every `retryInterval` milliseconds
 * until `timeout` milliseconds have passed, then it will reject the returned Promise.
 * If a connection is established, this function will wait for `rejectClosedSocket` milliseconds and
 * if the connection is closed during that time, it will retry connecting. This is sometimes necessary
 * if you connect through a TCP proxy (which is the case if you connect to exposed ports of a docker
 * container or through an ssh tunnel): the proxy may accept the connection and then immediately close
 * it again if it can't establish a connection to its target port.
 */
export declare function createConnection(
/** the port to connect to */
port: number, opts?: {
    /** the host to connect to, the default is localhost */
    host?: string;
    /** the amount of time (in milliseconds) to retry before giving up */
    timeout?: number;
    /** the amount of time (in milliseconds) to sleep before retrying */
    retryInterval?: number;
    /** the amount of time (in milliseconds) to wait after connecting to see if the
     * connection is closed again. The default is 10, set this to 0 to disable
     * this mechanism. */
    rejectClosedSocket?: number;
    log?: ILog;
}): Promise<net.Socket>;
/**
 * Wait for a connection on the given port and return the socket if successful.
 * This function will wait for a connection for `timeout` milliseconds and reject the returned
 * Promise if no connection is received within that time. If a connection is received, this
 * function will close the TCP server, i.e. it will not accept more than one connection.
 */
export declare function receiveConnection(
/** the port to listen on */
port: number, opts?: {
    /** the address to listen on (this is the second argument to [`server.listen()`]() */
    host?: string;
    /** the amount of time (in milliseconds) to wait for a connection before giving up */
    timeout?: number;
    log?: ILog;
}): Promise<net.Socket>;
/**
 * Send a message via the given `socket`. The given message is JSON-encoded and a newline character appended
 */
export declare function writeMessage(socket: net.Socket, msg: any): Promise<void>;
/**
 * Receive messages on the given socket. The data from the socket is split into lines and each line
 * is parsed using `JSON.parse()`
 */
export declare function readMessages<T>(socket: net.Socket, handler: (msg: T) => void): void;
