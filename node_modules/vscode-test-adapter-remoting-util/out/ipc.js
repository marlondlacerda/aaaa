"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readMessages = exports.writeMessage = exports.receiveConnection = exports.createConnection = void 0;
const tslib_1 = require("tslib");
const net = tslib_1.__importStar(require("net"));
const split_1 = tslib_1.__importDefault(require("split"));
/**
 * Connect to the given port and return the socket if successful.
 * If the connection is rejected, this function will keep retrying every `retryInterval` milliseconds
 * until `timeout` milliseconds have passed, then it will reject the returned Promise.
 * If a connection is established, this function will wait for `rejectClosedSocket` milliseconds and
 * if the connection is closed during that time, it will retry connecting. This is sometimes necessary
 * if you connect through a TCP proxy (which is the case if you connect to exposed ports of a docker
 * container or through an ssh tunnel): the proxy may accept the connection and then immediately close
 * it again if it can't establish a connection to its target port.
 */
function createConnection(
/** the port to connect to */
port, opts) {
    const options = opts || {};
    const host = options.host;
    const timeout = (options.timeout !== undefined) ? options.timeout : 5000;
    const retryInterval = options.retryInterval || 200;
    const rejectClosedSocket = (options.rejectClosedSocket !== undefined) ? options.rejectClosedSocket : 10;
    const log = options.log;
    if (timeout > 0) {
        return retry(() => createConnection(port, Object.assign(Object.assign({}, opts), { timeout: 0 })), timeout, retryInterval);
    }
    else {
        return new Promise((resolve, reject) => {
            function onConnect() {
                return tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (log)
                        log.info('IPC client connected to server');
                    socket.removeListener('error', onError);
                    if (rejectClosedSocket > 0) {
                        yield delay(rejectClosedSocket);
                        if (socket.destroyed) {
                            if (log)
                                log.info('IPC client socket was closed immediately');
                            reject(new Error('IPC client socket was closed immediately'));
                            return;
                        }
                    }
                    resolve(socket);
                });
            }
            function onError(err) {
                if (log)
                    log.info(`IPC client failed to connect to server: ${err}`);
                socket.removeListener('connect', onConnect);
                reject(err);
            }
            const socket = net.createConnection(port, host);
            socket.once('connect', onConnect);
            socket.once('error', onError);
        });
    }
}
exports.createConnection = createConnection;
/**
 * Wait for a connection on the given port and return the socket if successful.
 * This function will wait for a connection for `timeout` milliseconds and reject the returned
 * Promise if no connection is received within that time. If a connection is received, this
 * function will close the TCP server, i.e. it will not accept more than one connection.
 */
function receiveConnection(
/** the port to listen on */
port, opts) {
    const options = opts || {};
    const host = options.host;
    const timeout = (options.timeout !== undefined) ? options.timeout : 5000;
    const log = options.log;
    return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        function onConnection(socket) {
            if (log) {
                log.info('IPC server received client connection');
                socket.once('end', () => {
                    log.info('IPC server received disconnect from client');
                });
            }
            // only one connection should be accepted, so we're closing the server now
            // (this won't close the connection that was just established)
            server.close();
            if (timeoutHandle) {
                clearTimeout(timeoutHandle);
            }
            resolve(socket);
        }
        function onTimeout() {
            if (log)
                log.error('IPC server timed out before receiving a client connection');
            server.removeListener('connection', onConnection);
            server.close();
            reject(new Error('IPC server timed out before receiving a client connection'));
        }
        let timeoutHandle;
        if (timeout > 0) {
            timeoutHandle = setTimeout(onTimeout, timeout);
        }
        const server = yield createServerAndListen(port, host, log);
        server.on('connection', onConnection);
    }));
}
exports.receiveConnection = receiveConnection;
/**
 * Send a message via the given `socket`. The given message is JSON-encoded and a newline character appended
 */
function writeMessage(socket, msg) {
    return new Promise(resolve => socket.write(JSON.stringify(msg) + '\n', resolve));
}
exports.writeMessage = writeMessage;
/**
 * Receive messages on the given socket. The data from the socket is split into lines and each line
 * is parsed using `JSON.parse()`
 */
function readMessages(socket, handler) {
    socket.pipe(split_1.default()).on('data', (data) => {
        if (data) {
            handler(JSON.parse(data));
        }
    });
}
exports.readMessages = readMessages;
function createServerAndListen(port, host, log) {
    return new Promise((resolve, reject) => {
        function onListening() {
            if (log)
                log.info(`IPC server is listening on port ${port}`);
            server.removeListener('error', onError);
            resolve(server);
        }
        function onError(err) {
            if (log)
                log.error(`IPC server failed listening: ${err}`);
            server.removeListener('listening', onListening);
            reject(err);
        }
        const server = net.createServer();
        if (log)
            log.info('IPC server created');
        server.once('listening', onListening);
        server.once('error', onError);
        server.listen(port, host);
    });
}
function retry(fn, timeout, retryInterval, log) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const endTime = Date.now() + timeout;
        while (true) {
            try {
                return yield fn();
            }
            catch (err) {
                if (Date.now() >= endTime) {
                    if (log)
                        log.warn('Giving up.');
                    throw err;
                }
                else {
                    yield delay(retryInterval);
                    if (log)
                        log.info('Retrying...');
                }
            }
        }
    });
}
function delay(milliseconds) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}
//# sourceMappingURL=ipc.js.map